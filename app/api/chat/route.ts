import { google } from "@ai-sdk/google";
import { streamText, UIMessage, convertToModelMessages, tool } from "ai";
import { z } from "zod";
import { callN8nWorkflow } from "@/lib/n8n-client";
import { getWorkflowWebhookUrl } from "@/lib/n8n-config";
import { getWebhookModeFromCookieHeader } from "@/lib/webhook-mode";
import { getStreamingUpdateUrl } from "@/lib/n8n-client/config";
import { NextResponse } from "next/server";

/**
 * Zod schema for validating chat request body
 * Validates the messages array structure with flexible content formats
 */
const chatRequestSchema = z.object({
  messages: z.array(
    z.object({
      role: z.enum(["user", "assistant", "system", "tool"]),
      content: z.union([z.string(), z.array(z.unknown()), z.record(z.string(), z.unknown())]).optional(),
      parts: z.union([z.string(), z.array(z.unknown()), z.record(z.string(), z.unknown())]).optional(),
    }).passthrough() // Allow additional properties for flexibility
  ).min(1, "Messages array must contain at least one message"),
});

/**
 * Extract chatInput from messages array
 * Converts the conversation history into a format suitable for N8N workflows
 */
function extractChatInput(messages: UIMessage[]): string {
  if (!messages || messages.length === 0) {
    console.warn("[extractChatInput] Empty messages array");
    return "";
  }

  // Log messages for debugging
  console.log("[extractChatInput] Processing", messages.length, "messages");
  
  // Try to find the last user message specifically
  const userMessages = messages.filter(m => m.role === "user");
  const lastUserMessage = userMessages[userMessages.length - 1];

  if (!lastUserMessage) {
    console.warn("[extractChatInput] No user message found");
    return "";
  }

  console.log("[extractChatInput] Last user message:", JSON.stringify(lastUserMessage, null, 2));

  // Extract content from the last user message
  // Handle both 'content' and 'parts' fields (different message formats)
  const messageRecord = lastUserMessage as unknown as Record<string, unknown>;
  const messageData = messageRecord.parts || messageRecord.content;
  
  let content = "";
  if (typeof messageData === "string") {
    content = messageData;
  } else if (Array.isArray(messageData)) {
    content = messageData
      .map((part: unknown) => {
        if (typeof part === "string") return part;
        // Handle various object structures for text parts
        if (part && typeof part === "object") {
          const partObj = part as Record<string, unknown>;
          if (partObj.type === "text" && typeof partObj.text === "string") return partObj.text;
          if (typeof partObj.text === "string") return partObj.text;
          // Fallback for other structures
          return JSON.stringify(part);
        }
        return "";
      })
      .filter(Boolean)
      .join("");
  } else if (messageData && typeof messageData === "object") {
    // Handle case where content/parts is a single object (not array)
    const contentObj = messageData as Record<string, unknown>;
    if (typeof contentObj.text === "string") {
      content = contentObj.text;
    } else {
      content = JSON.stringify(contentObj);
    }
  }

  if (content && content.trim() !== "") {
    console.log("[extractChatInput] Successfully extracted:", content.substring(0, 100));
    return content;
  }

  console.error("[extractChatInput] Failed to extract text from last user message, using raw content");
  return typeof messageData === "string" 
    ? messageData 
    : JSON.stringify(messageData);
}

export async function POST(req: Request) {
  // Parse and validate request body
  let body: unknown;
  try {
    body = await req.json();
  } catch (error) {
    console.error("[chat/route] Failed to parse request body as JSON:", error);
    return NextResponse.json(
      {
        error: "Invalid JSON in request body",
        message: error instanceof Error ? error.message : "Failed to parse request body",
      },
      { status: 400 }
    );
  }

  // Validate request structure with Zod
  const validationResult = chatRequestSchema.safeParse(body);
  if (!validationResult.success) {
    console.error("[chat/route] Request validation failed:", validationResult.error.format());
    return NextResponse.json(
      {
        error: "Invalid request format",
        details: validationResult.error.format(),
        message: "The request body must contain a 'messages' array with at least one message object containing a 'role' field.",
      },
      { status: 400 }
    );
  }

  const { messages: validatedMessages } = validationResult.data;
  // Cast to UIMessage[] for AI SDK compatibility (Zod validation ensures structure is correct)
  // Note: UIMessage requires 'id' which may be generated by the client, so we cast through unknown
  const messages = validatedMessages as unknown as UIMessage[];
  
  // Get webhook mode from cookies
  const cookieHeader = req.headers.get("cookie");
  const webhookMode = getWebhookModeFromCookieHeader(cookieHeader);
  console.log(`[chat/route] ðŸ”§ Webhook Mode: ${webhookMode}`);

  const paragonOS = tool({
    description: "Call ParagonOS to handle messaging operations on Discord and Telegram. Use this tool when the user wants to check messages, send DMs, search conversations, manage contacts, or perform any messaging-related task. Extract a clear, scoped task from the conversation context and pass it in natural language. ParagonOS will handle the execution planning and tool sequencing.",
    inputSchema: z.object({
      prompt: z.string().describe("A clear, scoped task extracted from the conversation context. Use the conversation history to understand what the user is actually asking, then formulate a specific, less-ambiguous task in natural language. Include relevant details like platform (Discord/Telegram), channel/group names, contact names, time ranges, or topics when mentioned. Examples: 'Check for unreplied messages in the metarune management group on Telegram', 'Send a DM to sebastian on Discord about the deployment status', 'List all pending messages across both platforms', 'Search for messages about the token launch in metarune-labs Discord channel'."),
    }),
    execute: async ({ prompt }: { prompt: string }) => {
      // The prompt parameter is required by the schema
      let chatInput = prompt;
      
      // Validate the provided prompt
      if (!chatInput || chatInput.trim() === "") {
        console.warn("[paragonOS] Empty prompt parameter provided, attempting to extract from messages array");
        chatInput = extractChatInput(messages);
      }
      
      // Final validation
      if (!chatInput || chatInput.trim() === "") {
        return {
          success: false,
          error: "Cannot send empty request. The prompt parameter must contain the user's actual request or question.",
        };
      }
      
      console.log("[paragonOS] Using chatInput (length:", chatInput.length, "):", chatInput.substring(0, 100));
      
      // Get the stream URL for updates using unified URL construction
      const streamUrl = getStreamingUpdateUrl(req);
      
      // Prepare payload in the format N8N webhook expects
      const payload = {
        stage: "context_enrichment",
        status: "in_progress",
        message: "Processing request...",
        data: {
          chatInput: chatInput,
        },
        streamUrl: streamUrl,
      };
      
      const webhookUrl = getWorkflowWebhookUrl("paragonOS", webhookMode);
      console.log(`[chat/route] ðŸŽ¯ Webhook URL: ${webhookUrl}`);
      if (!webhookUrl) {
        return {
          success: false,
          error: "ParagonOS workflow is not configured. Please set the webhook URL in n8n-config.ts",
        };
      }

      const result = await callN8nWorkflow({
        webhookUrl,
        method: "POST",
        payload,
      });

      if (!result.success) {
        return {
          success: false,
          error: result.error || "Failed to execute ParagonOS workflow",
        };
      }

      return {
        success: true,
        message: "Request sent to ParagonOS successfully",
        data: result.data,
      };
    },
  });

  try {
    const result = streamText({
      model: google("models/gemini-2.5-pro"),
      messages: convertToModelMessages(messages),
      system: `You are an assistant that helps users interact with ParagonOS, a messaging platform management system for Discord and Telegram.

Your role:
1. Use the conversation history to understand what the user is actually asking
2. Determine if the request can be achieved using ParagonOS (messaging operations like checking messages, sending DMs, searching conversations, managing contacts, etc.)
3. If the request is ParagonOS-appropriate:
   - Call the paragonOS tool with a clear, less-ambiguous, scoped task in natural language
   - Extract the core intent from the conversation context
   - Make it specific (include platform, channel/group names, contact names, time ranges, etc. when mentioned)
   - Keep it natural language - don't over-process it
4. If the request is NOT about messaging operations or is a general question:
   - Respond directly without calling the tool

Examples of good prompts to pass to ParagonOS:
- "Check for unreplied messages in the metarune management group on Telegram"
- "Send a DM to sebastian on Discord asking about the deployment status"
- "List all pending messages that need replies across both Discord and Telegram"
- "Search for messages about the token launch in the metarune-labs Discord channel"

ParagonOS is capable of handling ambiguity in execution - your job is just to extract a clear, scoped task from the conversation.`,
      tools: {
        paragonOS,
      },
    });

    return result.toUIMessageStreamResponse();
  } catch (error) {
    console.error("[chat/route] Error processing chat request:", error);
    return NextResponse.json(
      {
        error: "Failed to process chat request",
        message: error instanceof Error ? error.message : "An unexpected error occurred",
      },
      { status: 500 }
    );
  }
}
